connection.py:
<code>
# mentor/core/engine/Connection.py
import os
import google.generativeai as genai
from dotenv import load_dotenv
from typing import List, Dict, Any, Optional

class Connection:
    def __init__(self):
        """Initializes the connection to the Google Gemini API."""
        load_dotenv() # Load environment variables from .env file

        self.api_key = os.getenv("GOOGLE_API_KEY")
        # Use Gemini 1.5 Flash as requested, allow override via .env
        self.model_name = os.getenv("GEMINI_MODEL_NAME")

        if not self.api_key:
            raise ValueError("Missing GOOGLE_API_KEY in environment variables. Please check your .env file.")

        # Configure the Gemini client
        genai.configure(api_key=self.api_key)

        # This client object represents your "LLM" connection.
        self.client = genai.GenerativeModel(self.model_name)

    def get_llm(self) -> genai.GenerativeModel:
        """
        Returns the initialized GenerativeModel client instance.
        """
        return self.client

    def get_llm_deployment_name(self) -> str:
        """
        Returns the name of the Gemini model (e.g., "gemini-2.5-flash").
        """
        return self.model_name

    async def generate_chat_completion(
        self,
        messages: List[Dict[str, Any]],
        temperature: float = 0.3,
        max_tokens: int = 2024,
        json_mode: bool = False,
        system_instruction: Optional[str] = None
    ) -> str:
        """
        Makes a chat completion call using the configured Gemini client.
        This method encapsulates the actual API interaction.
        """
        # Map OpenAI-style message roles to Gemini's format.
        chat_history = []
        effective_system_instruction = system_instruction

        for msg in messages:
            role = msg.get("role")
            content = msg.get("content")

            if role == "assistant":
                role = "model"
            
            if role in ["user", "model"]:
                chat_history.append({"role": role, "parts": [content]})
            elif role == "system" and effective_system_instruction is None:
                # If a system message is in the history and not passed separately,
                # use its content as the system instruction.
                effective_system_instruction = content

        # Configure the generation parameters for the API call
        generation_config = genai.types.GenerationConfig(
            temperature=temperature,
            max_output_tokens=max_tokens,
        )
        if json_mode:
            # Instruct Gemini to output a JSON object
            generation_config.response_mime_type = "application/json"

        # Use a model instance with the system instruction, if provided
        model_to_use = self.client
        if effective_system_instruction:
            model_to_use = genai.GenerativeModel(
                self.model_name,
                system_instruction=effective_system_instruction
            )

        try:
            response = await model_to_use.generate_content_async(
                contents=chat_history,
                generation_config=generation_config,
            )
            # Handle cases where the response might be blocked by safety settings
            if not response.candidates:
                feedback = response.prompt_feedback
                print(f"‚ùå Gemini API: Response was blocked. Reason: {feedback.block_reason}")
                if feedback.safety_ratings:
                    for rating in feedback.safety_ratings:
                        print(f"  - {rating.category}: {rating.probability}")
                return "I'm sorry, I couldn't generate a response due to the content safety filter."

            return response.text.strip()
        except Exception as e:
            print(f"‚ùå Gemini API error in generate_chat_completion: {e}")
            raise


# Example usage (updated for Gemini)
if __name__ == "__main__":
    import asyncio

    async def test():
        try:
            conn = Connection()
            # Get the LLM client and model name
            llm_model = conn.get_llm()
            llm_model_name = conn.get_llm_deployment_name()

            print(f"Obtained LLM Client: {type(llm_model)}")
            print(f"Using Model Name: {llm_model_name}")

            # Prepare messages in the standard format
            messages_to_send: List[Dict[str, Any]] = [{"role": "user", "content": "Tell me a short, funny story about a talking parrot."}]

            print(f"\nAttempting to generate chat completion...")
            # Use the helper method to get the completion
            reply = await conn.generate_chat_completion(messages=messages_to_send)
            print("‚úÖ LLM Response:\n", reply)

        except ValueError as ve:
            print(f"Configuration Error: {ve}")
        except Exception as e:
            print(f"An unexpected error occurred during test: {e}")
            import traceback
            traceback.print_exc()

    asyncio.run(test())
</code>

README.md:
<code>

# AI Mentor Chatbot- Mentora

This project is a **production-ready, AI Mentor Platform**. It enables users to log in, initiate learning sessions, and receive tailored guidance from an AI that adapts its mentoring style based on the user's professional role (e.g., Executive, Technical).

---

## üîß Features

- **Secure User Authentication**: Login required to access the chatbot.
- **Session Management**: Resume or start new learning sessions.
- **Role-Based AI Mentoring**: Custom mentoring style for each user role.
- **Centralized Prompt Management**: All prompts are configurable.
- **Text-to-Speech Output**: Mentor speaks the responses aloud.
- **Clean Architecture**: Modular, scalable, and production-ready codebase.

---

</code>

mentor\backend\fastapi_backend.py:
<code>
import os
import sys
import json
import datetime
import uuid
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Tuple

# Adjusting system path to locate necessary modules
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../../")))
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'core')))
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'shared', 'storage')))

# Importing custom modules for database operations and the core engine
from shared.storage.handle_user import validate_login
from shared.storage.handle_mentor_chat_history import (
    save_chat,
    get_chats,
    get_chat_messages_with_state,
    save_user_preferences,
    get_user_preferences,
    init_db
)
from mentor.core.engine.mentor_engine import MentorEngine

# Initialize the FastAPI application
app = FastAPI()

# --- Startup Event ---
@app.on_event("startup")
async def startup_event():
    """Initializes the database when the application starts."""
    init_db()
    print("Database initialized.")

# --- CORS Middleware ---
# Allows cross-origin requests, essential for web frontends
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods (GET, POST, etc.)
    allow_headers=["*"],  # Allows all headers
)

# Instantiate the core mentor engine
engine = MentorEngine()

# --- Pydantic Models for Request Bodies ---
class LoginRequest(BaseModel):
    user_id: str
    password: str

class ChatMessage(BaseModel):
    role: str
    content: str
    timestamp: Optional[float] = None
    audio_url: Optional[str] = None

class ChatRequest(BaseModel):
    user_id: str
    chat_title: str
    chat_history: List[ChatMessage]

class StartSessionRequest(BaseModel):
    user_id: str
    learning_goal: Optional[str] = None
    skills: List[str]
    difficulty: str
    role: str

class TopicPromptRequest(BaseModel):
    topic: str
    user_id: Optional[str] = None

# --- API Endpoints ---

@app.get("/")
async def read_root():
    """Root endpoint to check if the API is running."""
    return {"message": "Mentora Me API is running!"}

@app.post("/login")
async def login(req: LoginRequest):
    """Handles user login and validation."""
    print(f"-> /login called with user_id={req.user_id}")
    try:
        valid = validate_login(req.user_id, req.password)
        if not valid:
            raise HTTPException(status_code=401, detail="Invalid credentials")
        return {"success": True, "user_id": req.user_id}
    except Exception as e:
        print(f"Login error: {e}")
        raise HTTPException(status_code=500, detail="Login failed")

@app.post("/start_session")
async def start_session(req: StartSessionRequest):
    """Starts a new learning session for a user."""
    print(f"-> Starting session for user: {req.user_id}")
    try:
        # Save user preferences for the session
        save_user_preferences(
            user_id=req.user_id,
            learning_goal=req.learning_goal,
            skills=req.skills,
            difficulty=req.difficulty,
            role=req.role
        )
        print(f"Saved general preferences for user {req.user_id}")

        # Build context for the mentor engine
        context = (
            f"Skills/Interests: {', '.join(req.skills)}\n"
            f"Difficulty: {req.difficulty}\n"
            f"User Role: {req.role}"
        )
        if req.learning_goal:
            context = f"Learning Goal: {req.learning_goal}\n" + context

        extra_instructions = (
            "You are a mentor who is very interactive and strict to particular domain. if someone asked something which is not related to that domain. give fallback answer. ask questions, quiz the user, "
            "summarize lessons, and check understanding."
        )

        # Generate introductory message and topics from the engine
        intro, topics, suggestions = await engine.generate_intro_and_topics(
            context_description=context,
            extra_instructions=extra_instructions
        )

        initial_current_topic = topics[0] if topics else None
        
        # Create a unique session title
        base_title_part = req.learning_goal or (req.skills[0] if req.skills else "New Session")
        sanitized_base_title = "".join(c for c in base_title_part if c.isalnum() or c == ' ').strip().replace(' ', '_')
        if not sanitized_base_title:
            sanitized_base_title = "Session"
        session_title = f"{sanitized_base_title}_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}_{str(uuid.uuid4())[:4]}"

        mentor_message_content = intro + "\n\nFeel free to ask questions anytime. Are you ready to begin?"
        mentor_message_content = mentor_message_content.replace("üîä", "").strip()

        # Create the initial message for the chat history
        initial_chat_history_entry = ChatMessage(
            role="assistant",
            content=mentor_message_content,
            timestamp=datetime.datetime.now().timestamp(),
            audio_url=None
        )

        # Save the new chat session to the database
        save_chat(
            user_id=req.user_id,
            title=session_title,
            messages_json=json.dumps([initial_chat_history_entry.dict()]),
            mentor_topics=topics,
            current_topic=initial_current_topic,
            completed_topics=[]
        )

        print(f"Session started successfully with title: {session_title}")
        # Return all necessary information to the frontend
        return {
            "intro_and_topics": mentor_message_content,
            "title": session_title,
            "topics": topics,
            "current_topic": initial_current_topic,
            "suggestions": suggestions
        }
    except Exception as e:
        print(f"X Error starting session: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Could not start session: {str(e)}")

@app.post("/chat")
async def chat(req: ChatRequest):
    """Handles an ongoing chat conversation."""
    print(f"-> /chat called by user: {req.user_id} for chat: '{req.chat_title}'")
    try:
        # Retrieve current chat state from the database
        result = get_chat_messages_with_state(req.user_id, req.chat_title)
        if result is None or not isinstance(result, tuple) or len(result) != 2:
            print("get_chat_messages_with_state returned None or unexpected format!")
            chat_messages, state = [], {}
        else:
            chat_messages, state = result

        # Extract session state and user preferences
        mentor_topics = state.get("mentor_topics", [])
        current_topic = state.get("current_topic")
        completed_topics = state.get("completed_topics", [])
        prefs = get_user_preferences(req.user_id)
        learning_goal = prefs.get("learning_goal")
        skills = prefs.get("skills", [])
        difficulty = prefs.get("difficulty", "medium")
        role = prefs.get("role", "student")

        # Pass all necessary context, including chat_title, to the engine
        reply, suggestions = await engine.chat(
            chat_history=[msg.dict() for msg in req.chat_history],
            user_id=req.user_id,
            chat_title=req.chat_title,
            learning_goal=learning_goal,
            skills=skills,
            difficulty=difficulty,
            role=role,
            mentor_topics=mentor_topics,
            current_topic=current_topic,
            completed_topics=completed_topics
        )

        # Create the new assistant message object
        mentor_message = ChatMessage(
            role="assistant",
            content=reply,
            timestamp=datetime.datetime.now().timestamp(),
            audio_url=None
        )

        # Update and save the chat history
        updated_history = req.chat_history + [mentor_message]
        save_chat(
            user_id=req.user_id,
            title=req.chat_title,
            messages_json=json.dumps([msg.dict() for msg in updated_history]),
            mentor_topics=mentor_topics,
            current_topic=current_topic,
            completed_topics=completed_topics
        )

        # Return both reply and suggestions to the frontend
        return {"reply": reply, "suggestions": suggestions}
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error in chat: {e}")
        raise HTTPException(status_code=500, detail="Chat failed")

@app.get("/get_chats")
async def list_chats(user_id: str = Query(..., description="User ID")):
    """Retrieves a list of all past chat sessions for a user."""
    print(f"-> /get_chats called for user_id='{user_id}'")
    try:
        chats = get_chats(user_id)
        return {"chats": chats}
    except Exception as e:
        print(f"Error getting chats: {e}")
        raise HTTPException(status_code=500, detail="Failed to get chats")

@app.get("/get_chat_messages")
async def get_chat_messages_route(user_id: str = Query(..., description="User ID"), title: str = Query(..., description="Chat Title")):
    """Retrieves all messages and state for a specific chat session."""
    print(f"-> /get_chat_messages called with user_id='{user_id}', title='{title}'")
    try:
        result = get_chat_messages_with_state(user_id, title)
        if result is None or not isinstance(result, tuple) or len(result) != 2:
            print("get_chat_messages_with_state returned None or unexpected format!")
            messages, state = [], {}
        else:
            messages, state = result
        return {"messages": messages, "state": state}
    except Exception as e:
        print(f"Error getting chat messages: {e}")
        raise HTTPException(status_code=500, detail="Failed to get chat messages")

@app.post("/get_topic_prompts")
async def get_topic_prompts(req: TopicPromptRequest):
    """Generates suggested user prompts for a given topic."""
    try:
        prefs = get_user_preferences(req.user_id) if req.user_id else {}
        context = ""
        if prefs:
            context = f"Learning Goal: {prefs.get('learning_goal','')}\nSkills: {', '.join(prefs.get('skills',[]))}\nDifficulty: {prefs.get('difficulty','')}\nRole: {prefs.get('role','')}"
        prompts = await engine.generate_topic_prompts(req.topic, context_description=context)
        return {"prompts": prompts}
    except Exception as e:
        # Fallback prompts in case of an error
        return {"prompts": [
            f"What are the basics of {req.topic}?",
            f"Can you give me a real-world example of {req.topic}?",
            f"How do I apply {req.topic} in practice?",
            f"What are common mistakes in {req.topic}?"
        ]}

</code>

mentor\core\config\config.yaml:
<code>
prompt_templates:
  technical: |
    As an interactive AI mentor, provide the following components for a learner's introduction:
    1.  A warm, brief, and catchy opening greeting.
    2.  A list of key topic titles for the learning journey. These should be concise and relevant. In the topics you generate, include a mix of basic understanding, real-world application, practical usage, and common mistakes. It should have end to end what all you required someone to learn for that skill. Like examples, use cases, etc.
    3.  A single, direct concluding question to engage the learner, asking about their readiness or first topic choice.
    4.  Four suggested questions or prompts that the learner might want to ask next. These should be relevant to the topics and engaging. Return them as a list of strings.

    Do NOT provide any markdown formatting (like bolding, bullet points, or extra descriptions) for the topic titles or suggestions within the JSON output, other than the list structure itself.
    IMPORTANT: Do not include any personally identifiable information in your response.

    {instructions_clause}
    {default_behavior}

    Learner context:
    {context_description}

    Your response MUST be in the following JSON format:
    {{
      "greeting": "Your friendly and encouraging short introductory message.",
      "topics": [
        "Topic 1 Title",
        "Topic 2 Title",
        "..."
      ],
      "concluding_question": "Your single, direct concluding question.",
      "suggestions": [
        "Suggestion 1",
        "Suggestion 2",
        "Suggestion 3",
        "Suggestion 4"
      ]
    }}
    Ensure 'topics' and 'suggestions' contain only the exact strings.

  executive: |
    As a business-oriented AI mentor, provide the following for an executive learner:
    1.  A friendly professional greeting tailored to executives, highlighting business outcomes, strategic vision, and value.
    2.  A list of key topic titles focusing on business strategy, executive decision-making, implementation at scale, ROI, business challenges, and high-level impacts relating to the skill or subject. Include real-world use cases and business transformation examples.
    3.  A single, direct concluding question relevant to executive priorities, such as "Which business function or priority would you like to start with?"
    4.  Four sample follow-up questions or prompts, focusing on maximizing business value, strategy, change management, executive KPIs, or measuring impact.

    Do NOT provide any markdown formatting (like bolding, bullet points, or extra descriptions) for the topic titles or suggestions within the JSON output, other than the list structure itself.
    IMPORTANT: Do not include any personally identifiable information in your response.

    {instructions_clause}
    {default_behavior}

    Learner context:
    {context_description}

    Your response MUST be in the following JSON format:
    {{
      "greeting": "Your business-focused short introductory message.",
      "topics": [
        "Topic 1 Title",
        "Topic 2 Title",
        "..."
      ],
      "concluding_question": "Your business-focused concluding question.",
      "suggestions": [
        "How does this drive value?",
        "Can this improve our KPIs?",
        "What are the strategic risks?",
        "How can our teams adopt this?"
      ]
    }}
    Ensure 'topics' and 'suggestions' contain only the exact strings.

  techno_functional: |
    As an AI mentor for a techno-functional learner, provide the following:
    1.  A greeting for someone bridging both business and technical areas, acknowledging their hybrid role.
    2.  A list of topic titles reflecting both functional processes and the supporting technology. Include real-world implementation, business process optimization, and practical integration points.
    3.  A concluding question encouraging them to choose between starting with business context or technical deep-dive, e.g., "Would you like to explore business flows or technology details first?"
    4.  Four prompts that toggle between business impact and technical feasibility, such as balancing requirements, use-case prioritization, adoption challenges, and value realization.

    Do NOT provide any markdown formatting (like bolding, bullet points, or extra descriptions) for the topic titles or suggestions within the JSON output, other than the list structure itself.
    IMPORTANT: Do not include any personally identifiable information in your response.

    {instructions_clause}
    {default_behavior}

    Learner context:
    {context_description}

    Your response MUST be in the following JSON format:
    {{
      "greeting": "Your hybrid business-technical short intro.",
      "topics": [
        "Topic 1 Title",
        "Topic 2 Title",
        "..."
      ],
      "concluding_question": "Your concluding question for a techno-functional user.",
      "suggestions": [
        "How does tech support this?",
        "What is the business impact?",
        "Where do tech and process meet?",
        "Any integration best practices?"
      ]
    }}
    Ensure 'topics' and 'suggestions' contain only the exact strings.

</code>

mentor\core\engine\mentor_engine.py:
<code>
# mentor/core/engine/mentor_engine.py

import os
import sys
import json
import yaml
from typing import Optional, Tuple, List, Dict, Any

# Adjust system path to find the 'connection' module
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", "..")))
from connection import Connection

class MentorEngine:
    def __init__(self):
        """Initializes the MentorEngine."""
        self.conn = Connection()
        self.llm_client = self.conn.get_llm()
        self.llm_deployment_name = self.conn.get_llm_deployment_name()
        
        self.prompts = self._load_yaml("prompts.yaml")
        self.conversation_summaries = {}

    def _load_yaml(self, filename: str) -> Dict[str, Any]:
        """Loads a YAML file from the same directory."""
        path = os.path.join(os.path.dirname(__file__), filename)
        with open(path, "r", encoding="utf-8") as f:
            return yaml.safe_load(f)

    def _validate_and_sanitize_input(self, input_text: str) -> str:
        return input_text

    def _sanitize_output(self, output_text: str) -> str:
        # PII sanitization was removed. This is now a pass-through.
        return output_text

    def _clean_json_response(self, raw_response: str) -> str:
        """
        Cleans the raw LLM response to isolate the JSON object.
        Removes markdown fences (```json ... ```) and other surrounding text.
        """
        # Find the start of the JSON object
        start_brace = raw_response.find('{')
        # Find the end of the JSON object
        end_brace = raw_response.rfind('}')
        
        if start_brace != -1 and end_brace != -1 and end_brace > start_brace:
            # Extract the content between the first '{' and the last '}'
            return raw_response[start_brace:end_brace+1]
        
        # If no JSON object is found, return the original string to let the parser fail
        return raw_response

    async def _get_conversation_summary(self, chat_title: str, chat_history: List[Dict[str, Any]]) -> str:
        SUMMARY_THRESHOLD = 10
        if len(chat_history) < SUMMARY_THRESHOLD:
            return self.conversation_summaries.get(chat_title, "")

        messages_to_summarize = chat_history[:-5]
        summary_prompt = self.prompts["tasks"]["summarize_conversation"]
        
        summary_messages = [{"role": "system", "content": summary_prompt}]
        summary_messages.extend(messages_to_summarize)

        try:
            summary = await self.conn.generate_chat_completion(
                messages=summary_messages,
                temperature=0.3,
                max_tokens=250
            )
            self.conversation_summaries[chat_title] = summary
            print(f"Generated new summary for chat '{chat_title}': {summary}")
            return summary
        except Exception as e:
            print(f"Error generating conversation summary: {e}")
            return self.conversation_summaries.get(chat_title, "")

    async def generate_intro_and_topics(
        self,
        context_description: str,
        extra_instructions: Optional[str] = None,
        role: Optional[str] = None
    ) -> Tuple[str, List[str], List[str]]:
        context_description = self._validate_and_sanitize_input(context_description)
        extra_instructions = self._validate_and_sanitize_input(extra_instructions) if extra_instructions else ""
        
        default_behavior = self.prompts["default_instructions"]
        role_prompt = self.prompts["roles"].get(role, self.prompts["roles"]["default"])
        prompt_template = self.prompts["tasks"]["generate_intro_and_topics"]

        prompt_content = prompt_template.format(
            extra_instructions=extra_instructions,
            default_behavior=default_behavior,
            role_prompt=role_prompt,
            context_description=context_description
        )
        messages = [{"role": "user", "content": prompt_content}]
        
        try:
            llm_raw_response = await self.conn.generate_chat_completion(
                messages=messages,
                temperature=0.5,
                max_tokens=800,
                json_mode=True
            )
            # ** NEW: Clean the response before parsing **
            cleaned_response = self._clean_json_response(llm_raw_response)
            parsed = json.loads(cleaned_response)
            
            greeting = self._sanitize_output(parsed.get("greeting", "Hello!"))
            topics = [self._sanitize_output(t) for t in parsed.get("topics", [])]
            question = self._sanitize_output(parsed.get("concluding_question", "Shall we start?"))
            suggestions = [self._sanitize_output(s) for s in parsed.get("suggestions", [])]
            
            intro_message = f"{greeting}\n\nHere are the topics we'll explore:\n- " + "\n- ".join(topics) + f"\n\n{question}"
            return (intro_message, topics, suggestions)
        except Exception as e:
            print(f"Error in generate_intro_and_topics: {e}")
            fallback_intro = "Hello! I'm your mentor, ready to guide you.\n\nHere are some topics:\n- Introduction\n- Core Concepts\n- Advanced Topics\n\nShall we start?"
            return fallback_intro, ["Introduction", "Core Concepts", "Advanced Topics"], ["What should I focus on first?", "Can you explain the first topic?", "How does this relate to my goal?", "Can you quiz me on a topic?"]

    async def chat(
        self,
        chat_history: List[Dict[str, Any]],
        user_id: str,
        chat_title: str,
        learning_goal: Optional[str],
        skills: List[str],
        difficulty: str,
        role: str,
        mentor_topics: Optional[List[str]] = None,
        current_topic: Optional[str] = None,
        completed_topics: Optional[List[str]] = None,
    ) -> Tuple[str, List[str]]:
        if not chat_history:
            return "Please start the conversation with a message.", []

        summary = await self._get_conversation_summary(chat_title, chat_history)
        recent_history = chat_history[-6:]

        system_prompt = self._build_system_context(learning_goal, skills, difficulty, role, mentor_topics, current_topic, completed_topics)
        
        if summary:
            user_prompt_wrapper = self.prompts["tasks"]["chat"]["user_prompt_wrapper"]
            system_prompt += "\n\n" + user_prompt_wrapper.format(summary=summary)

        try:
            llm_raw_response = await self.conn.generate_chat_completion(
                messages=recent_history,
                system_instruction=system_prompt,
                temperature=0.7,
                max_tokens=1500,
                json_mode=True
            )
            # ** NEW: Clean the response before parsing **
            cleaned_response = self._clean_json_response(llm_raw_response)
            parsed = json.loads(cleaned_response)

            reply = self._sanitize_output(parsed.get("reply", "I'm sorry, I couldn't form a proper reply."))
            suggestions = [self._sanitize_output(s) for s in parsed.get("suggestions", [])]
            return reply, suggestions
        except json.JSONDecodeError as e:
            print(f"CRITICAL: LLM failed to produce valid JSON. Error: {e}. Raw Response: {llm_raw_response}")
            return "I seem to be having trouble formatting my thoughts. Please try rephrasing your question.", []
        except Exception as e:
            print(f"Error in chat: {e}")
            return "I'm sorry, I couldn't understand your question. Could you please rephrase it?", []

    def _build_system_context(
        self, learning_goal, skills, difficulty, role, mentor_topics, current_topic, completed_topics
    ) -> str:
        context_lines = [f"Role: {role}"]
        if learning_goal: context_lines.append(f"Learning Goal: {learning_goal}")
        if skills: context_lines.append(f"Skills: {', '.join(skills)}")
        context_lines.append(f"Difficulty: {difficulty}")
        if mentor_topics: context_lines.append(f"Topics: {', '.join(mentor_topics)}")
        if current_topic: context_lines.append(f"Current Topic: {current_topic}")
        if completed_topics: context_lines.append(f"Completed Topics: {', '.join(completed_topics)}")
        
        role_instruction = self.prompts["roles"].get(role, self.prompts["roles"]["default"])
        default_instruction = self.prompts["default_instructions"]
        json_output_instruction = self.prompts["shared_components"]["json_output_format"]
        system_prompt_template = self.prompts["tasks"]["chat"]["system_prompt"]

        return system_prompt_template.format(
            context_summary="\n".join(context_lines),
            role_instruction=role_instruction,
            default_instruction=default_instruction,
            json_output_instruction=json_output_instruction
        )
    
    async def generate_topic_prompts(
        self,
        topic: str,
        context_description: str = "",
        role: Optional[str] = None
    ) -> list:
        topic = self._validate_and_sanitize_input(topic)
        context_description = self._validate_and_sanitize_input(context_description)
        
        role_prompt = self.prompts["roles"].get(role, self.prompts["roles"]["default"])
        prompt_template = self.prompts["tasks"]["generate_topic_prompts"]
        
        prompt_content = prompt_template.format(
            topic=topic,
            role_prompt=role_prompt,
            context_description=context_description
        )
        messages = [{"role": "user", "content": prompt_content}]
        
        try:
            llm_response = await self.conn.generate_chat_completion(
                messages=messages,
                temperature=0.5,
                max_tokens=500,
                json_mode=True
            )
            # ** NEW: Clean the response before parsing **
            cleaned_response = self._clean_json_response(llm_response)
            prompts = json.loads(cleaned_response)

            return [self._sanitize_output(p) for p in prompts]
        except Exception as e:
            print(f"Error in generate_topic_prompts: {e}")
            return [f"What are the basics of {topic}?", f"Give me an example of {topic}", f"How to apply {topic}?", f"Common mistakes in {topic}?"]
</code>

mentor\core\engine\prompts.yaml:
<code>
# ===============================================================
# AI Mentor Chatbot - Master Prompt Configuration
# ===============================================================
# This file contains all prompts, roles, and instructions for the AI mentor.

# ---------------------------------------------------------------
# SECTION 1: DEFAULT INSTRUCTIONS & BEHAVIOR
# These are the base rules that apply to the mentor in all situations.
# ---------------------------------------------------------------
default_instructions: |
  ## Core Mentor Behavior
  - You are a mentor who is very interactive. Ask questions, quiz the user with relevant MCQs, summarize lessons, and check for understanding.
  - Give examples and real-world scenarios to make learning engaging.
  - Guide the user through topics sequentially unless they ask to revisit or skip.
  - Foster a continuous learning mindset.
  - If a user asks something not related to the established learning domain, kindly redirect them to start a new session with an appropriate mentor. Do not attempt to answer out-of-domain questions.

  ## Critical Safety Instruction
  - IMPORTANT: You MUST NOT include any personally identifiable information (PII) in your responses. This includes, but is not limited to, names, email addresses, phone numbers, social security numbers, addresses, or IP addresses.

# ---------------------------------------------------------------
# SECTION 2: ROLE-SPECIFIC PERSONAS
# Defines how the mentor should adapt its style for different user roles.
# ---------------------------------------------------------------
roles:
  default: |
    ## Persona: General Mentor
    - You are mentoring a general user. Adapt your style based on the context provided.

  Executive: |
    ## Persona: Executive Mentor
    - You are mentoring a non-technical senior leader (CXO, VP, Director).
    - Focus on high-level topics: market dynamics, emerging business models, industry case studies, digital strategy, ROI analysis, and regulatory impact.
    - Avoid deep technical jargon and fundamental setup steps (e.g., library installation, basic syntax).
    - Use simple, strategic language with a forward-thinking tone.
    - Encourage the application of knowledge to strategic planning and decision-making.

  Techno Functional: |
    ## Persona: Techno-Functional Mentor
    - You are mentoring a user who bridges business and technology.
    - Focus on system architecture, business process flows, functional use cases, system integration (ERP, CRM, APIs), and problem-solving with tools like SQL or BPM.
    - Keep a balance between technical logic (how it works) and business purpose (why it matters).
    - Avoid getting lost in deep coding details or high-level business politics.

  Technical: |
    ## Persona: Technical Mentor
    - You are mentoring a hands-on technical user (developer, engineer, data scientist).
    - Focus on programming (Java, Python, SQL), software architecture, system performance, DevOps (CI/CD, Docker), data structures, algorithms, and security.
    - Prioritize hands-on examples, code snippets, error debugging, and system design challenges.
    - Encourage best practices, performance tuning, and real-world problem-solving.

# ---------------------------------------------------------------
# SECTION 3: TASK-SPECIFIC PROMPTS
# These are the templates for specific actions the mentor performs.
# ---------------------------------------------------------------
tasks:
  ## Task: Generate the initial greeting and topic list for a new session.
  generate_intro_and_topics: |
    As an interactive AI mentor, your task is to generate an introduction for a new learning session.

    ## Learner Context
    {context_description}

    ## Role-Specific Instructions
    {role_prompt}

    ## General Instructions
    {default_behavior}
    {extra_instructions}

    ## Your Response Format
    You MUST provide your response as a single JSON object with the following keys:
    - "greeting": A warm, brief, and catchy opening greeting.
    - "topics": A list of no more than 5 relevant topic titles.
    - "concluding_question": A single, direct question to engage the learner.
    - "suggestions": A list of exactly 4 relevant follow-up questions the learner might ask.

    CRITICAL: Your entire output must be ONLY the JSON object, starting with { and ending with }. Do not add any conversational text or markdown code fences like ```json.
    IMPORTANT: The strings in the "topics" and "suggestions" lists must not contain any markdown formatting.

  ## Task: Handle a turn in an ongoing chat conversation.
  chat:
    system_prompt: |
      {context_summary}
      {role_instruction}
      {default_instruction}
      {json_output_instruction}

    user_prompt_wrapper: |
      Here is a summary of our conversation so far:
      {summary}
      Remember your goal is to teach the user about the agreed-upon mentor topics. If the user asks about something else within the same skill domain (e.g., asking about 'pandas' during a 'Python' session), you should answer it but gently remind them of the topics you need to cover. If they ask about a completely different skill (e.g., 'Java' during a 'Python' session), tell them to open a new session with a Java mentor.
      Now, continue the conversation based on the most recent messages.

  ## Task: Summarize the conversation history to maintain context.
  summarize_conversation: |
    You are a summarization expert. Concisely summarize the key points, user goals, and progress in the following conversation. Focus on information that would be essential for a mentor to remember to continue the conversation effectively.

  ## Task: Generate suggested prompts for a given topic.
  generate_topic_prompts: |
    You are an interactive AI mentor. For the topic "{topic}", generate 4 engaging, beginner-friendly prompts or questions that a learner might want to ask next. Each question should be short (5-6 words).

    ## Role-Specific Instructions
    {role_prompt}

    ## Learner Context
    {context_description}

    ## Your Response Format
    Return ONLY a JSON array of strings, with no explanations or extra text.
    CRITICAL: Your entire output must be ONLY the JSON array, starting with [ and ending with ]. Do not add any conversational text or markdown code fences like ```json.

# ---------------------------------------------------------------
# SECTION 4: SHARED COMPONENTS
# Reusable blocks, like the required JSON output format.
# ---------------------------------------------------------------
shared_components:
  json_output_format: |
    --- OUTPUT FORMAT ---
    You MUST provide your response as a single JSON object. This object must contain two keys:
    1. "reply": (string) Your main conversational response to the user. Use Markdown for formatting.
    2. "suggestions": (list of strings) A list of 3-4 short, relevant follow-up questions or prompts to guide the user.

    CRITICAL: Your entire output must be ONLY the JSON object, starting with { and ending with }. Do not add any conversational text or markdown code fences like ```json.
    
    Example:
    {
      "reply": "This is the main answer to the user's question.",
      "suggestions": ["Tell me more.", "Give me an example.", "What's next?"]
    }
</code>

mentor\ui\index.html:
<code>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Mentora - Learn, Grow, and Achieve</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex-shrink: 0;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        
        .header-title-container {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            justify-content: center;
        }

        .header-title-container .logo {
            width: 40px;
            height: 40px;
        }

        header h1 {
            font-size: 2.2rem;
            font-weight: 600;
        }
        
        #logged-in-user-container {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: rgba(255, 255, 255, 0.15);
            padding: 6px 12px;
            border-radius: 20px;
            width: 200px;
            justify-content: flex-end;
        }
        #logged-in-user-container span {
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #logged-in-user {
            font-weight: bold;
            color: #ffffff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        .footer {
            text-align: center;
            padding: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex-shrink: 0;
            font-size: 0.9rem;
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
            width: 100%;
            padding: 20px;
            gap: 20px;
        }

        .sidebar {
            width: 280px;
            min-width: 250px;
            background-color: #ffffff;
            padding: 1.5rem;
            border-radius: 15px;
            overflow-y: auto;
            flex-shrink: 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .sidebar h4 {
            margin-top: 0;
            margin-bottom: 0.75rem;
            color: #4a5568;
            font-size: 1.1rem;
            font-weight: 600;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 8px;
        }

        #past-sessions {
            list-style: none;
            padding-left: 0;
            margin-top: 1rem;
            margin-bottom: 0;
        }

        #past-sessions li {
            background: #f8f9fa;
            margin-bottom: 0.75rem;
            padding: 0.8rem 1rem;
            border-radius: 10px;
            cursor: pointer;
            border-left: 4px solid transparent;
            transition: all 0.3s ease;
        }

        #past-sessions li:hover {
            transform: translateX(5px);
            background: #e9ecef;
            border-left: 4px solid #667eea;
        }

        .session-title {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 0.2rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .session-meta {
            font-size: 0.8rem;
            color: #6c757d;
            margin-bottom: 0.3rem;
        }

        .session-snippet {
            font-size: 0.85rem;
            color: #495057;
            max-height: 2.8em;
            line-height: 1.4em;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .main-content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background-color: #f8f9fa99;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .message {
            max-width: 80%;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message.assistant {
            align-self: flex-start;
        }

        .message-icon {
            flex-shrink: 0;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .message.user .message-icon {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .message.assistant .message-icon {
            background-color: #96c2f0;
        }

        .message-icon svg {
            width: 22px;
            height: 22px;
        }
        .message.user .message-icon svg {
            fill: white;
        }
        .message.assistant .message-icon svg {
            fill: #343a40;
        }

        .message-bubble {
            padding: 12px 18px;
            position: relative;
            word-wrap: break-word;
            white-space: pre-wrap;
            line-height: 1.0;
        }

        .message.user .message-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 18px 18px 4px 18px;
        }

        .message.assistant .message-bubble {
            background-color: #b4caf652;
            color: #343a40;
            border-radius: 18px 18px 18px 4px;
        }
        
        .message.assistant .message-bubble ul {
            padding-left: 20px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .message.assistant .message-bubble li {
            margin-bottom: 2px;
        }
        .message.assistant .message-bubble p {
            margin-bottom: 0.5em;
        }
        .message.assistant .message-bubble p:last-child {
            margin-bottom: 0;
        }
        
        .mentor-icon::before {
            content: none;
        }

        .message-bubble-footer {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-top: 8px;
        }

        .message time {
            font-size: 0.75rem;
            color: #adb5bd;
            user-select: none;
        }
        .message.user time {
            color: #e0e0e0;
        }

        .input-box {
            display: flex;
            padding: 1rem 1.5rem;
            background-color: #ffffff;
            border-top: 1px solid #dee2e6;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .input-box textarea {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #dee2e6;
            border-radius: 20px;
            font-size: 1rem;
            resize: none;
            min-height: 48px;
            max-height: 150px;
            overflow-y: auto;
            font-family: inherit;
            transition: border-color 0.3s ease;
        }
        .input-box textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .hidden {
            display: none !important;
        }

        .form-group {
            margin-bottom: 25px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
            font-size: 1rem;
        }

        select, input[type="text"], input[type="password"] {
            width: 100%;
            padding: 12px;
            font-size: 1rem;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            font-family: inherit;
            transition: border-color 0.3s ease;
        }
        select:focus, input[type="text"]:focus, input[type="password"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }
        .btn-primary:disabled {
            background: #b3b9e8;
            cursor: not-allowed;
        }

        #send-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        #send-btn:hover:not(:disabled) {
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
            transform: translateY(-1px);
        }
        #send-btn:disabled {
            background: #b3b9e8;
            cursor: not-allowed;
        }
        #send-btn svg {
            width: 24px;
            height: 24px;
            fill: white;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }


        .btn-secondary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border: transparent;}
        .btn-secondary:hover:not(:disabled) {
            background: #cbd5e0;
        }

        .login {
            max-width: 450px;
            margin: auto;
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        .login h2 {
            text-align: center;
            margin-bottom: 15px;
            color: #4a5568;
            font-size: 1.8rem;
        }

        .setup {
            padding: 40px;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            overflow-y: auto;
        }
        .setup-content {
            max-width: 500px;
            width: 100%;
        }
        .setup h2 {
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 1.8rem;
        }

        .setup .form-group {
            text-align: left;
        }
        
        #typing-indicator {
            font-style: italic;
            color: #666;
            margin: 0 1.5rem 0.5rem;
            height: 1.5rem;
            user-select: none;
            text-align: left;
            padding-left: 5px;
        }

        .skill-tag {
            background: #e9ecef;
            color: #495057;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            font-size: 0.95rem;
            font-weight: 500;
            white-space: nowrap;
        }
        .skill-tag:hover {
            border-color: #bdc5e8;
        }

        .skill-tag.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        #selected-skills-display {
            border: 2px solid #e2e8f0;
            padding: 10px;
            min-height: 48px;
            border-radius: 8px;
            background-color: #fff;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            margin-top: 10px;
        }
        .selected-skill-item {
            background-color: #667eea;
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            white-space: nowrap;
        }
        .selected-skill-item .remove-skill {
            background: none;
            border: 1px solid white;
            color: white;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            font-size: 0.8em;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 16px;
            width: 16px;
            border-radius: 50%;
        }

        #custom-skill-input-container {
            margin-top: 10px;
        }
        #custom-skill-input-container button {
            padding: 12px 18px;
            font-size: 0.9rem;
        }

        .suggestion-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            border-radius: 10px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.85rem;
            border:transparent;
            transition: background-color 0.3s ease;
        }
        .suggestion-btn:hover {
            background-color: #cbd5e0;
        }
        #suggestion-buttons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 0 1.5rem 1rem;
        }

        /* --- Voice button Icon Styling --- */
        #voice-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        #voice-btn:hover:not(:disabled) {
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
            transform: translateY(-1px);
        }
        #voice-btn svg {
            width: 24px;
            height: 24px;
            fill: white;
        }
        #voice-btn.listening {
            background: #e53e3e; /* Red background when listening */
            animation: pulse-red 1.5s infinite;
        }
        #voice-btn.listening svg {
            fill: white;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(229, 62, 62, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(229, 62, 62, 0); }
            100% { box-shadow: 0 0 0 0 rgba(229, 62, 62, 0); }
        }

        /* --- Replay Audio Button on Message --- */
        .replay-audio-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px;
            margin-left: 8px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        .replay-audio-btn:hover {
            opacity: 1;
        }
        .replay-audio-btn svg {
            width: 16px;
            height: 16px;
            fill: #4a5568;
        }
        .message.user .replay-audio-btn {
            display: none; /* Don't show for user messages */
        }
    </style>
</head>
<body>

    <header>
        <div style="width: 200px;"></div> <div class="header-title-container">
            <svg class="logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#a29bfe;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#667eea;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <path fill="url(#logoGradient)" d="M50,5A45,45,0,1,1,5,50,45,45,0,0,1,50,5M50,0a50,50,0,1,0,50,50A50,50,0,0,0,50,0Z"/>
                <path fill="white" d="M50 20 L 30 35 L 50 50 L 70 35 L 50 20 Z M 50 55 L 30 70 L 50 85 L 70 70 L 50 55 Z"/>
            </svg>
            <h1>Mentora</h1>
            <p>Learn, Grow, and Achieve</p>
        </div>
        <div id="logged-in-user-container" class="hidden">
            <span>Logged in as: </span>
            <span id="logged-in-user"></span>
        </div>
    </header>

    <div class="login" id="login-section">
        <h2>Welcome Back!</h2>
        <p style="text-align: center; color: #6c757d; margin-bottom: 25px; font-size: 1rem;">
            Your personalized AI-powered mentor to help you master any skills. Learn, Grow, and Achieve with interactive sessions tailored to your needs.
        </p>
        <div class="form-group">
            <label for="userId">User ID:</label>
            <input type="text" id="userId" />
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" />
        </div>
        <button id="login-btn" class="btn btn-primary" style="width: 100%;" onclick="login()">Login</button>
        <p id="login-error" style="color: #e53e3e; margin-top: 15px; text-align: center;"></p>
    </div>

    <div class="container hidden" id="main-app-container">
        <div class="sidebar">
            <button onclick="showSetupSection()" class="btn btn-secondary" style="margin-bottom: 1rem; width: 100%;">New Session</button>
            <h4>Previous Sessions</h4>
            <ul id="past-sessions" title="Click to load session"></ul>
        </div>

        <div class="main-content-area" id="dynamic-content-area">
            <div class="setup" id="setup-section">
                <div class="setup-content">
                    <h2>Personalize Your Learning Journey</h2>
                    <div class="form-group">
                        <label for="Choose_Your_Persona">Choose Your Persona:</label>
                        <select id="role">
                            <option value="Techno_Functional">Techno Functional</option>
                            <option value="Executive">Executive</option>
                            <option value="Technical">Technical</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="difficulty">Choose Your Level:</label>
                        <select id="difficulty">
                            <option value="Beginner">Beginner</option>
                            <option value="Intermediate">Intermediate</option>
                            <option value="Advanced">Advanced</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Skills:</label>
                        <div id="skills-selection-container" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;">
                            <span class="skill-tag predefined" data-skill="Gen AI">Gen AI</span>
                            <span class="skill-tag predefined" data-skill="Python">Python</span>
                            <span class="skill-tag predefined" data-skill="Machine Learning">Machine Learning</span>
                            <span class="skill-tag predefined" data-skill="JAVA">JAVA</span>
                            <span class="skill-tag predefined" data-skill="Agentic AI">Agentic AI</span>
                            <span class="skill-tag predefined" data-skill="Others" id="others-skill-tag">Others</span>
                        </div>
                        <div id="custom-skill-input-container" class="hidden" style="display: flex; gap: 5px;">
                            <input type="text" id="custom-skill-input" placeholder="Type custom skill" style="flex: 1;"/>
                            <button type="button" class="btn btn-primary" onclick="addCustomSkill()">Add</button>
                        </div>
                        <div id="selected-skills-display">
                            <span id="no-skills-selected" style="color: #999; font-size: 0.9rem;">Click skills above to add</span>
                        </div>
                        <input type="hidden" id="selected-skills-hidden-input" name="selected_skills" value="" />
                    </div>
                    
                    
                    <button onclick="startSession()" class="btn btn-primary" style="width: 100%;">Start Session</button>
                </div>
            </div>

            <div class="chat-area hidden" id="chat-messages-area">
                <div class="messages" id="chat-messages"></div>
                <div id="suggestion-buttons-container"></div>
                <div id="typing-indicator" class="hidden">Mentora is thinking...</div>
                <div class="input-box">
                    <textarea id="user-input" placeholder="Ask your Mentora..." rows="1"></textarea>
                    <!-- Voice Input Button -->
                    <button id="voice-btn" title="Use Voice Input">
                        <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.49 6-3.31 6-6.72h-1.7z"></path></svg>
                    </button>
                    <button id="send-btn" onclick="sendMessage()">
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        Powered by H
    </div>

    <script>
        let chatHistory = [];
        let userId = "";
        let currentChatTitle = null;
        let currentTopic = null;
        let typingTimeout;
        const loginBtn = document.getElementById('login-btn');
        const sendBtn = document.getElementById('send-btn');
        const typingIndicator = document.getElementById('typing-indicator');
        const mainAppContainer = document.getElementById('main-app-container');
        const setupSection = document.getElementById('setup-section');
        const chatMessagesArea = document.getElementById('chat-messages-area');
        const chatMessagesDiv = document.getElementById('chat-messages');
        const skillsSelectionContainer = document.getElementById('skills-selection-container');
        const othersSkillTag = document.getElementById('others-skill-tag');
        const customSkillInputContainer = document.getElementById('custom-skill-input-container');
        const customSkillInput = document.getElementById('custom-skill-input');
        const selectedSkillsDisplay = document.getElementById('selected-skills-display');
        const noSkillsSelectedSpan = document.getElementById('no-skills-selected');
        const selectedSkillsHiddenInput = document.getElementById('selected-skills-hidden-input');
        const loggedInUserContainer = document.getElementById('logged-in-user-container');
        let currentSelectedSkills = new Set();
        const API_BASE_URL = 'http://127.0.0.1:8084';
        
        // --- Initialize Markdown Converter ---
        const converter = new showdown.Converter();

        // --- SVG Icons ---
        const sendIconSVG = `<svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>`;
        const loadingSpinnerHTML = `<div class="loading-spinner"></div>`;
        const replayIconSVG = `<svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>`;

        // --- Web Speech API Setup ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const SpeechSynthesis = window.speechSynthesis;
        const voiceBtn = document.getElementById('voice-btn');
        const userInput = document.getElementById('user-input');
        let recognition;
        let isListening = false;
        let currentlyPlayingUtterance = null;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            voiceBtn.addEventListener('click', () => {
                if (isListening) {
                    recognition.stop();
                } else {
                    recognition.start();
                }
            });

            recognition.onstart = () => {
                isListening = true;
                voiceBtn.classList.add('listening');
                voiceBtn.title = "Stop Listening";
            };

            recognition.onend = () => {
                isListening = false;
                voiceBtn.classList.remove('listening');
                voiceBtn.title = "Use Voice Input";
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                userInput.value = transcript;
                userInput.style.height = 'auto';
                userInput.style.height = (userInput.scrollHeight) + 'px';
            };

            recognition.onerror = (event) => {
                console.error("Speech recognition error:", event.error);
                alert(`Speech recognition error: ${event.error}`);
            };
        } else {
            voiceBtn.style.display = 'none';
            console.warn("Web Speech API for recognition not supported in this browser.");
        }

        function speak(text, onEndCallback) {
            if (SpeechSynthesis && text) {
                if (SpeechSynthesis.speaking) {
                    SpeechSynthesis.cancel();
                }
                const utterance = new SpeechSynthesisUtterance(text);
                currentlyPlayingUtterance = utterance;
                utterance.onend = () => {
                    currentlyPlayingUtterance = null;
                    if (onEndCallback) {
                        onEndCallback();
                    }
                };
                utterance.onerror = (event) => {
                    console.error("SpeechSynthesis Error", event);
                    currentlyPlayingUtterance = null;
                };
                SpeechSynthesis.speak(utterance);
            }
        }

        function toggleSpeak(text, btnElement) {
            if (SpeechSynthesis.speaking && currentlyPlayingUtterance && currentlyPlayingUtterance.text === text) {
                SpeechSynthesis.cancel(); // This will trigger the onend event in speak()
            } else {
                // Remove 'speaking' class from all other buttons first
                document.querySelectorAll('.replay-audio-btn.speaking').forEach(b => b.classList.remove('speaking'));
                
                speak(text, () => {
                    btnElement.classList.remove('speaking');
                });
                btnElement.classList.add('speaking');
            }
        }
        // --- End of Web Speech API Setup ---


        function setSendButtonToSend() {
            sendBtn.innerHTML = sendIconSVG;
            sendBtn.disabled = false;
        }

        function setSendButtonToLoading() {
            sendBtn.innerHTML = loadingSpinnerHTML;
            sendBtn.disabled = true;
        }

        userInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });

        userInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        skillsSelectionContainer.addEventListener('click', (event) => {
            const target = event.target;
            if (target.classList.contains('skill-tag') && target.dataset.skill) {
                const skill = target.dataset.skill;
                if (skill === "Others") {
                    if (customSkillInputContainer.classList.contains('hidden')) {
                        customSkillInputContainer.classList.remove('hidden');
                        target.classList.add('selected');
                        if (!currentSelectedSkills.has("Others")) {
                            currentSelectedSkills.add("Others");
                            updateSelectedSkillsDisplay();
                        }
                        customSkillInput.focus();
                    } else {
                        customSkillInputContainer.classList.add('hidden');
                        target.classList.remove('selected');
                        currentSelectedSkills.delete("Others");
                        updateSelectedSkillsDisplay();
                    }
                } else {
                    if (currentSelectedSkills.has(skill)) {
                        currentSelectedSkills.delete(skill);
                        target.classList.remove('selected');
                    } else {
                        currentSelectedSkills.add(skill);
                        target.classList.add('selected');
                    }
                    updateSelectedSkillsDisplay();
                }
            }
        });

        function addCustomSkill() {
            const skill = customSkillInput.value.trim();
            if (skill && !currentSelectedSkills.has(skill)) {
                currentSelectedSkills.add(skill);
                updateSelectedSkillsDisplay();
                customSkillInput.value = "";
                customSkillInput.focus();
            } else if (currentSelectedSkills.has(skill)) {
                alert(`"${skill}" is already added.`);
            }
        }

        function removeSkill(skillToRemove) {
            currentSelectedSkills.delete(skillToRemove);
            if (skillToRemove === "Others") {
                othersSkillTag.classList.remove('selected');
                customSkillInputContainer.classList.add('hidden');
            }
            document.querySelectorAll('.skill-tag.predefined').forEach(tag => {
                if (tag.dataset.skill === skillToRemove) {
                    tag.classList.remove('selected');
                }
            });
            updateSelectedSkillsDisplay();
        }

        function updateSelectedSkillsDisplay() {
            selectedSkillsDisplay.innerHTML = '';
            if (currentSelectedSkills.size === 0) {
                selectedSkillsDisplay.appendChild(noSkillsSelectedSpan);
                noSkillsSelectedSpan.classList.remove('hidden');
            } else {
                noSkillsSelectedSpan.classList.add('hidden');
                currentSelectedSkills.forEach(skill => {
                    const skillItem = document.createElement('span');
                    skillItem.className = 'selected-skill-item';
                    skillItem.textContent = skill;
                    const removeButton = document.createElement('button');
                    removeButton.className = 'remove-skill';
                    removeButton.textContent = 'x';
                    removeButton.onclick = () => removeSkill(skill);
                    skillItem.appendChild(removeButton);
                    selectedSkillsDisplay.appendChild(skillItem);
                });
            }
            selectedSkillsHiddenInput.value = JSON.stringify(Array.from(currentSelectedSkills));
        }

        document.addEventListener('DOMContentLoaded', () => {
             updateSelectedSkillsDisplay();
             setSendButtonToSend(); // Initialize send button icon
        });

        async function login() {
            userId = document.getElementById("userId").value.trim();
            const password = document.getElementById("password").value;
            const errorElem = document.getElementById("login-error");
            errorElem.textContent = "";
            if (!userId || !password) {
                errorElem.textContent = "Please enter User ID and Password.";
                return;
            }
            loginBtn.disabled = true;
            loginBtn.textContent = "Logging in...";
            try {
                const res = await fetch(`${API_BASE_URL}/login`, {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({user_id: userId, password})
                });
                if (res.ok) {
                    document.getElementById("login-section").classList.add("hidden");
                    mainAppContainer.classList.remove("hidden");
                    loggedInUserContainer.classList.remove("hidden"); // Show user info
                    showSetupSection();
                    document.getElementById("logged-in-user").textContent = userId;
                    const pref = localStorage.getItem(`prefs_${userId}`);
                    if (pref) {
                        try {
                            const parsed = JSON.parse(pref);
                            currentSelectedSkills = new Set(parsed.skills || []);
                            updateSelectedSkillsDisplay();
                            document.querySelectorAll('.skill-tag.predefined').forEach(tag => {
                                if (currentSelectedSkills.has(tag.dataset.skill)) {
                                    tag.classList.add('selected');
                                } else {
                                    tag.classList.remove('selected');
                                }
                            });
                            const hasNonPredefinedSkill = parsed.skills.some(s => !['Python', 'Machine Learning', 'Data Science', 'AI'].includes(s));
                            if (currentSelectedSkills.has("Others") || hasNonPredefinedSkill) {
                                othersSkillTag.classList.add('selected');
                                customSkillInputContainer.classList.remove('hidden');
                            } else {
                                othersSkillTag.classList.remove('selected');
                                customSkillInputContainer.classList.add('hidden');
                            }
                            if(parsed.difficulty) {
                                document.getElementById("difficulty").value = parsed.difficulty;
                            }
                            if(parsed.role) {
                                document.getElementById("role").value = parsed.role;
                            }
                        } catch { /* ignore parse errors */ }
                    }
                    await fetchChats();
                } else {
                    errorElem.textContent = "Login failed. Check credentials.";
                }
            } catch(e) {
                errorElem.textContent = "Error connecting to server.";
                console.error("Login error:", e);
            } finally {
                loginBtn.disabled = false;
                loginBtn.textContent = "Login";
            }
        }

        function showSetupSection() {
            setupSection.classList.remove("hidden");
            chatMessagesArea.classList.add("hidden");
            chatHistory = [];
            currentChatTitle = null;
            renderMessages();
            currentSelectedSkills.clear();
            updateSelectedSkillsDisplay();
            document.querySelectorAll('.skill-tag.predefined').forEach(tag => tag.classList.remove('selected'));
            customSkillInputContainer.classList.add('hidden');
            customSkillInput.value = "";
        }

        async function fetchChats() {
            try {
                const res = await fetch(`${API_BASE_URL}/get_chats?user_id=${encodeURIComponent(userId)}`);
                if (!res.ok) throw new Error("Failed to fetch chats. Status: " + res.status);
                const data = await res.json();
                const list = document.getElementById("past-sessions");
                list.innerHTML = "";
                if (!data.chats || data.chats.length === 0) {
                    const li = document.createElement("li");
                    li.textContent = "No previous sessions";
                    li.style.fontStyle = "italic";
                    li.style.color = "#666";
                    list.appendChild(li);
                    return;
                }
                data.chats.sort((a, b) => {
                    const dateA = new Date(a.created_at || a[2] || 0);
                    const dateB = new Date(b.created_at || b[2] || 0);
                    return dateB - dateA;
                });
                data.chats.forEach(chat => {
                    const chatId = chat.id || chat[0];
                    const chatTitle = chat.title || chat[1];
                    const chatCreatedAt = chat.created_at || chat[2];

                    const li = document.createElement("li");
                    li.title = chatTitle;
                    li.onclick = () => loadChat(chatTitle);

                    const titleDiv = document.createElement("div");
                    titleDiv.className = "session-title";
                    titleDiv.textContent = chatTitle.replace(/_\d{8,}_\w{4}$/, '').replace(/_/g, ' ');

                    const metaDiv = document.createElement("div");
                    metaDiv.className = "session-meta";
                    const dt = chatCreatedAt ? new Date(chatCreatedAt) : null;
                    metaDiv.textContent = dt ? dt.toLocaleString() : "No Date";

                    const snippetDiv = document.createElement("div");
                    snippetDiv.className = "session-snippet";
                    snippetDiv.textContent = ""; 

                    fetch(`${API_BASE_URL}/get_chat_messages?user_id=${encodeURIComponent(userId)}&title=${encodeURIComponent(chatTitle)}`)
                        .then(res => res.json())
                        .then(data => {
                            if (data.messages && data.messages.length > 0) {
                                const firstAssistant = data.messages.find(m => m.role === "assistant");
                                if (firstAssistant) {
                                    snippetDiv.textContent = firstAssistant.content.split('\n')[0].slice(0, 60) + "...";
                                }
                            }
                        });

                    li.appendChild(titleDiv);
                    li.appendChild(metaDiv);
                    li.appendChild(snippetDiv);
                    list.appendChild(li);
                });
            } catch (e) {
                console.error("Error fetching chats:", e);
                const list = document.getElementById("past-sessions");
                list.innerHTML = '<li style="color: red; font-style: italic;">Error loading sessions. Please check server.</li>';
            }
        }

        async function loadChat(title) {
            try {
                const res = await fetch(`${API_BASE_URL}/get_chat_messages?user_id=${encodeURIComponent(userId)}&title=${encodeURIComponent(title)}`);
                if (!res.ok) throw new Error("Failed to load chat messages. Status: " + res.status);
                const data = await res.json();
                chatHistory = data.messages || [];
                chatHistory.forEach(msg => {
                    msg.isIntro = false;
                    msg.isInitialIntro = false;
                    if (typeof msg.timestamp === 'string') {
                        msg.timestamp = parseFloat(msg.timestamp);
                    }
                });
                currentChatTitle = title;
                renderMessages();
                setupSection.classList.add("hidden");
                chatMessagesArea.classList.remove("hidden");
            } catch (e) {
                console.error("Error loading chat:", e);
                alert("Failed to load chat: " + title + ". See console for details.");
            }
        }

        async function startSession() {
            const skills = Array.from(currentSelectedSkills);
            const difficulty = document.getElementById("difficulty").value;
            const role = document.getElementById("role").value;
            if (skills.length === 0) {
                alert("Please select at least one skill.");
                return;
            }
            const startBtn = document.querySelector('.setup button');
            try {
                startBtn.disabled = true;
                startBtn.textContent = "Starting...";
                const res = await fetch(`${API_BASE_URL}/start_session`, {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({ user_id: userId, skills, difficulty, role })
                });
                if (!res.ok) throw new Error("Failed to start session. Status: " + res.status);
                const data = await res.json();
                localStorage.setItem(`prefs_${userId}`, JSON.stringify({ skills, difficulty, role }));
                setupSection.classList.add("hidden");
                chatMessagesArea.classList.remove("hidden");
                currentChatTitle = data.title;
                const introMessage = {
                    role: "assistant",
                    content: data.intro_and_topics,
                    timestamp: Date.now() / 1000,
                    isIntro: false,
                    isInitialIntro: true
                };
                chatHistory = [introMessage];
                displayMessage(introMessage);
                
                // speak(data.intro_and_topics); // This line was causing the issue

                if (data.suggestions && data.suggestions.length > 0) {
                    showPromptButtons(data.suggestions);
                }
                
                await fetchChats();
            } catch (e) {
                console.error("Error starting session:", e);
                alert("Failed to start session: " + e.message + ". Check console for details.");
            } finally {
                startBtn.disabled = false;
                startBtn.textContent = "Start Session";
            }
        }

        function renderMessages() {
            chatMessagesDiv.innerHTML = '';
            chatHistory.forEach(msg => {
                displayMessage(msg);
            });
            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
        }
        
        function displayMessage(messageObj) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', messageObj.role);

            const iconDiv = document.createElement('div');
            iconDiv.className = 'message-icon';
            if (messageObj.role === 'user') {
                iconDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>`;
            } else { 
                iconDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#343a40"><path d="M12 3L1 9l4 2.18v6.32l7 3.51 7-3.51v-6.32L23 9l-11-6zm-7 8.18L12 15l7-3.82L12 7.36 5 11.18zM12 16.5l-4-2v-3.5l4 2 4-2v3.5l-4 2z"/></svg>`;
            }

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = 'message-bubble';

            const htmlContent = converter.makeHtml(messageObj.content);
            const contentDiv = document.createElement('div');
            contentDiv.innerHTML = htmlContent;
            
            contentDiv.querySelectorAll('em').forEach(el => {
                el.style.color = '#555';
                el.style.display = 'block';
                el.style.fontSize = '0.9em';
                el.style.marginTop = '4px';
            });
            
            bubbleDiv.appendChild(contentDiv);

            const bubbleFooter = document.createElement('div');
            bubbleFooter.className = 'message-bubble-footer';

            const timeSpan = document.createElement('time');
            const date = messageObj.timestamp ? new Date(messageObj.timestamp * 1000) : new Date();
            timeSpan.textContent = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            bubbleFooter.appendChild(timeSpan);
            
            if (messageObj.role === 'assistant') {
                const replayBtn = document.createElement('button');
                replayBtn.className = 'replay-audio-btn';
                replayBtn.title = 'Play audio';
                replayBtn.innerHTML = replayIconSVG;
                replayBtn.onclick = () => toggleSpeak(messageObj.content, replayBtn);
                bubbleFooter.appendChild(replayBtn);
            }
            
            bubbleDiv.appendChild(bubbleFooter);

            messageDiv.appendChild(iconDiv);
            messageDiv.appendChild(bubbleDiv);

            chatMessagesDiv.appendChild(messageDiv);
            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
        }

        async function sendMessage() {
            const messageText = userInput.value.trim();
            if (messageText === '') return;
            if (!userId || !currentChatTitle) {
                alert("Please start or load a session first.");
                return;
            }

            const userMessageObject = {
                role: "user",
                content: messageText,
                timestamp: Date.now() / 1000
            };
            displayMessage(userMessageObject);
            chatHistory.push(userMessageObject);
            userInput.value = '';
            userInput.style.height = 'auto';
            
            setSendButtonToLoading();
            typingIndicator.classList.remove('hidden');
            document.getElementById('suggestion-buttons-container').innerHTML = ''; 

            try {
                const response = await fetch(`${API_BASE_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        user_id: userId,
                        chat_title: currentChatTitle,
                        chat_history: chatHistory
                    })
                });
                const data = await response.json();
                if (response.ok) {
                    const mentorMessageObject = {
                        role: "assistant",
                        content: data.reply,
                        timestamp: Date.now() / 1000,
                    };
                    displayMessage(mentorMessageObject);
                    chatHistory.push(mentorMessageObject);
                    
                    // speak(data.reply); // This line was causing the issue
                    
                    if (data.suggestions && Array.isArray(data.suggestions) && data.suggestions.length > 0) {
                        showPromptButtons(data.suggestions);
                    }

                } else {
                    let errorMessage = data.detail || `Server responded with status ${response.status}.`;
                    displayMessage({ role: 'assistant', content: `Error: ${errorMessage}`, timestamp: Date.now() / 1000 });
                }
            } catch (error) {
                console.error('Error sending message:', error);
                displayMessage({ role: 'assistant', content: 'Failed to get a response from the mentor. Please try again.', timestamp: Date.now() / 1000 });
            } finally {
                setSendButtonToSend();
                typingIndicator.classList.add('hidden');
            }
        }

        function showPromptButtons(prompts) {
            let container = document.getElementById('suggestion-buttons-container');
            container.innerHTML = '';
            if(!prompts) return;
            prompts.forEach(prompt => {
                const btn = document.createElement('button');
                btn.textContent = prompt;
                btn.className = 'suggestion-btn';
                btn.onclick = () => {
                    document.getElementById('user-input').value = prompt;
                    sendMessage();
                    container.innerHTML = '';
                };
                container.appendChild(btn);
            });
            container.style.display = prompts.length > 0 ? 'flex' : 'none';
        }

    </script>
</body>
</html>

</code>

shared\storage\create_user_data.py:
<code>
import sqlite3
from datetime import datetime
import os



DATABASE_DIR = os.path.join(os.path.dirname(__file__), '..', '..', 'data')
DATABASE_NAME = 'user_history.db'
DB_PATH = os.path.join(DATABASE_DIR, DATABASE_NAME)
conn = sqlite3.connect(DB_PATH, check_same_thread=False)
c = conn.cursor()

# Drop and create users table
c.execute('DROP TABLE IF EXISTS users')
conn.commit()

c.execute('''
CREATE TABLE users (
    user_id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    password TEXT NOT NULL,
    email TEXT NOT NULL,
    firm TEXT,
    unit TEXT,
    location TEXT,
    created_at TEXT NOT NULL
)
''')
conn.commit()

# Seed dummy users
dummy_users = [
    {
        "user_id": "harish",
        "name": "Harish",
        "password": "harish@123",
        "email": "harish@email.com",
        "firm": "Independent",
        "unit": "Gen AI",
        "location": "Bangalore"
    },
    {
        "user_id": "melvin",
        "name": "Melvin",
        "password": "Melvin@123",
        "email": "melvin@uk.com",
        "firm": "UK",
        "unit": "Gen AI",
        "location": "UK"
    }
]

now = datetime.utcnow().isoformat()

for user in dummy_users:
    c.execute('''
        INSERT INTO users (user_id, name, password, email, firm, unit, location, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', (user["user_id"], user["name"], user["password"], user["email"],
          user["firm"], user["unit"], user["location"], now))

conn.commit()
print("‚úÖ Database initialized and dummy users created.")

</code>

shared\storage\handle_mentor_chat_history.py:
<code>
# shared/storage/handle_mentor_chat_history.py
from typing import Optional, Tuple, List, Dict, Any
import json
import os
import sqlite3
import datetime

DATABASE_DIR = os.path.join(os.path.dirname(__file__), '..', '..', 'data')
DATABASE_NAME = 'mentor_data.db'
DATABASE_PATH = os.path.join(DATABASE_DIR, DATABASE_NAME)

def _get_db_connection():
    os.makedirs(DATABASE_DIR, exist_ok=True)
    conn = sqlite3.connect(DATABASE_PATH)
    conn.row_factory = sqlite3.Row # Allows accessing columns by name
    return conn

def init_db():
    with _get_db_connection() as conn:
        cursor = conn.cursor()
        # Table for chat messages (history)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS chats (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id TEXT NOT NULL,
                title TEXT NOT NULL,
                messages_json TEXT NOT NULL,
                mentor_topics TEXT,         -- JSON string of mentor's suggested topics
                current_topic TEXT,         -- Current topic being discussed
                completed_topics TEXT,      -- JSON string of completed topics
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(user_id, title) -- Ensures a user has unique chat titles
            )
        ''')
        # Table for user general preferences (not tied to a specific chat session)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS user_preferences (
                user_id TEXT PRIMARY KEY,
                learning_goal TEXT,
                skills TEXT,                -- JSON string of skills
                difficulty TEXT,
                role TEXT,
                updated_at TEXT DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        conn.commit()


def save_chat(user_id: str, title: str, messages_json: str, mentor_topics: Optional[List[str]] = None, current_topic: Optional[str] = None, completed_topics: Optional[List[str]] = None):
    with _get_db_connection() as conn:
        cursor = conn.cursor()
        mentor_topics_json = json.dumps(mentor_topics) if mentor_topics is not None else None
        completed_topics_json = json.dumps(completed_topics) if completed_topics is not None else None

        cursor.execute('''
            INSERT OR REPLACE INTO chats (user_id, title, messages_json, mentor_topics, current_topic, completed_topics)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (user_id, title, messages_json, mentor_topics_json, current_topic, completed_topics_json))
        conn.commit()

def get_chats(user_id: str):
    with _get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT id, title, created_at FROM chats WHERE user_id = ?", (user_id,))
        return cursor.fetchall()

def get_chat_messages_with_state(user_id: str, chat_title: str) -> Optional[Tuple[List[Dict[str, Any]], Dict[str, Any]]]:
    """
    Retrieves chat messages and the mentor session state for a given user and chat title.
    Returns a tuple of (messages, state) or None if not found.
    """
    with _get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute('''
            SELECT messages_json, mentor_topics, current_topic, completed_topics
            FROM chats
            WHERE user_id = ? AND title = ?
        ''', (user_id, chat_title))
        row = cursor.fetchone()

        if row:
            # Parse the JSON string of messages into a list of dictionaries
            messages = json.loads(row["messages_json"]) if row["messages_json"] else []
            
            # Prepare the state dictionary
            mentor_topics = json.loads(row["mentor_topics"]) if row["mentor_topics"] else []
            completed_topics = json.loads(row["completed_topics"]) if row["completed_topics"] else []
            state = {
                "mentor_topics": mentor_topics,
                "current_topic": row["current_topic"],
                "completed_topics": completed_topics
            }
            
            # Return a tuple of (messages, state)
            return messages, state
            
    # If no row is found, return None
    return None

def save_user_preferences(user_id: str, learning_goal: Optional[str], skills: List[str], difficulty: str, role: str):
    with _get_db_connection() as conn:
        cursor = conn.cursor()
        skills_json = json.dumps(skills)
        cursor.execute('''
            INSERT OR REPLACE INTO user_preferences (user_id, learning_goal, skills, difficulty, role, updated_at)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (user_id, learning_goal, skills_json, difficulty, role, datetime.datetime.now().isoformat()))
        conn.commit()

def get_user_preferences(user_id: str) -> Optional[Dict[str, Any]]:
    with _get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT learning_goal, skills, difficulty, role FROM user_preferences WHERE user_id = ?", (user_id,))
        row = cursor.fetchone()
        if row:
            skills = json.loads(row["skills"]) if row["skills"] else []
            return {
                "learning_goal": row["learning_goal"],
                "skills": skills,
                "difficulty": row["difficulty"],
                "role": row["role"]
            }
        return None

# Call init_db once when the module is imported to ensure tables exist
init_db()
</code>

shared\storage\handle_user.py:
<code>
import sqlite3
from datetime import datetime
import os

DATABASE_DIR = os.path.join(os.path.dirname(__file__), '..', '..', 'data')
DATABASE_NAME = 'user_history.db'
DB_PATH = os.path.join(DATABASE_DIR, DATABASE_NAME)
conn = sqlite3.connect(DB_PATH, check_same_thread=False)
c = conn.cursor()

# === Core User Functions ===

def create_user(user_id, name, password, email, firm, unit, location):
    now = datetime.utcnow().isoformat()
    c.execute('''
        INSERT OR IGNORE INTO users (
            user_id, name, password, email, firm, unit, location, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', (user_id, name, password, email, firm, unit, location, now))
    conn.commit()

def get_user(user_id):
    c.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
    return c.fetchone()

def get_all_users():
    c.execute('SELECT user_id, name, created_at FROM users ORDER BY created_at DESC')
    return c.fetchall()

def update_user_name(user_id, new_name):
    c.execute('UPDATE users SET name = ? WHERE user_id = ?', (new_name, user_id))
    conn.commit()

def validate_login(user_id, password):
    c.execute('SELECT * FROM users WHERE user_id = ? AND password = ?', (user_id, password))
    return c.fetchone() is not None

</code>

